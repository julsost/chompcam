<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Herbivory Tracking Tool — Static</title>

  
<!-- Minimal styling, modern but accessible -->
<style>
  :root{
    --accent:#6b7cff;
    --muted:#666;
    --bg:#f7f7fb;
    --panel:#efefef;
    --success:#16a34a;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color: #222;
  }
  html,body { height:100%; margin:0; background:var(--bg); }
  .app {
    display: grid;
    grid-template-columns: 1fr 420px;
    gap:20px;
    padding:18px;
    box-sizing:border-box;
    min-height:100%;
  }
  header { grid-column: 1 / -1; display:flex; align-items:center; justify-content:space-between; gap:12px; }
  h1 { margin:0; font-size:20px; }
  .left, .right { background:white; border-radius:8px; padding:14px; box-shadow:0 1px 0 rgba(0,0,0,.06); }
  .video-area { display:flex; flex-direction:column; gap:6px; }
  video { width:100%; max-height:58vh; background:#000; border-radius:6px; outline:1px solid #ddd; }
  .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .btn { background:var(--accent); color:white; border:none; padding:8px 10px; border-radius:6px; cursor:pointer; }
  .btn.secondary { background:#eee; color:#222; }
  label { font-size:13px; color:var(--muted); }
  input[type="text"], input[type="number"], input[type="date"], input[type="time"], select, textarea {
    padding:8px; border-radius:6px; border:1px solid #ccc; font-size:14px; width:100%;
    box-sizing:border-box; background:white;
  }
  .meta-grid { display:grid; grid-template-columns: repeat(3,1fr); gap:8px; margin-bottom:8px; }
  .meta-grid .full { grid-column: 1 / -1; }
  .scrub { display:flex; align-items:center; gap:8px; }
  input[type="range"] { width:100%; }
  .side-panel { display:flex; flex-direction:column; gap:8px; max-height:80vh; overflow:auto; }
  .species-card { background:var(--panel); border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center; gap:10px; }
  .species-info { display:flex; gap:10px; align-items:center; }
  .species-info img{ width:64px; height:44px; object-fit:cover; border-radius:6px; border:1px solid #ddd; }
  .species-name { font-weight:600; }
  .small { font-size:12px; color:var(--muted); }
  .log-actions { display:flex; gap:6px; align-items:center; }
  .pill { padding:6px 8px; border-radius:8px; background:#efe; border:1px solid #ddd; cursor:pointer; }
  .badge { background:white; padding:6px 8px; border-radius:8px; border:1px solid #ddd; }
  .highlight { border:2px solid var(--accent); box-shadow:0 6px 18px rgba(107,124,255,0.12); }
  footer { grid-column:1 / -1; display:flex; gap:12px; align-items:center; justify-content:space-between; padding-top:4px; color:var(--muted); }
  .file-list { display:flex; gap:8px; flex-wrap:wrap; }
  /* cropping overlay */
  .crop-overlay { position:relative; }
  canvas.cropcanvas { position:absolute; left:0; top:0; pointer-events:none; }
  /* responsive */
  @media (max-width:980px){
    .app{ grid-template-columns: 1fr; padding:12px;}
    .right{ order:2; }
    .left{ order:1; }
  }
</style>
</head>
<body>
<div class="app" id="app">
  <header>
    <h1>Herbivory Tracking Tool</h1>
    <div>
      <button class="btn" id="exportZipBtn" title="Export CSV + screenshots as ZIP">Export ZIP (CSV + images)</button>
      <button class="btn secondary" id="exportCsvBtn" title="Download CSV only">Export CSV</button>
    </div>
  </header>

  <!-- LEFT: video + metadata -->
  <section class="left" aria-labelledby="videoTitle">
    <h2 id="videoTitle" style="margin-top:0;font-size:16px">Video & Metadata</h2>

    <div class="meta-grid" role="group" aria-label="Video metadata">
      <div class="full">
        <label for="videoFile">Load GoPro video (MP4)</label>
        <input id="videoFile" type="file" accept="video/*" aria-describedby="videoFileDesc" />
        <div id="videoFileDesc" class="small">Choose local file. Filename auto-fills below but editable.</div>
      </div>

      <div>
        <label for="loc">Location</label>
        <input id="loc" type="text" placeholder="e.g., Reef A, Site 3" />
      </div>
      <div>
        <label for="date">Date</label>
        <input id="date" type="date" />
      </div>
      <div>
        <label for="time">Time</label>
        <input id="time" type="time" />
      </div>

      <div>
        <label for="transect">Transect #</label>
        <input id="transect" type="text" placeholder="Transect number" />
      </div>
      <div>
        <label for="reviewer">Reviewer</label>
        <input id="reviewer" type="text" placeholder="Your name" />
      </div>
      <div class="full">
        <label for="videoFilename">Video filename (editable)</label>
        <input id="videoFilename" type="text" placeholder="Video filename" />
      </div>
    </div>

    <div class="video-area" role="region" aria-label="Video player area">
      <div style="position:relative;">
        <video id="video" controls crossorigin="anonymous" preload="metadata"></video>
        <!-- an overlay canvas for cropping selection -->
        <canvas id="cropCanvas" class="cropcanvas" style="display:none;"></canvas>
      </div>

      <div class="controls" aria-hidden="false">
        <button class="btn" id="playPauseBtn">Play/Pause (Space)</button>

        <label for="speed">Speed</label>
        <select id="speed" aria-label="Playback speed">
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
          <option value="3">3x</option>
          <option value="4">4x</option>
          <option value="5">5x</option>
        </select>

        <label for="fps" class="small">FPS (for frame-step)</label>
        <input id="fps" type="number" min="1" step="1" value="30" style="width:80px" />

        <label for="autoAdvance" class="small">Auto-advance after log</label>
        <select id="autoAdvance" style="width:120px">
          <option value="none">None</option>
          <option value="0.2">+0.2s</option>
          <option value="0.5">+0.5s</option>
          <option value="1">+1s</option>
        </select>

        <div style="flex:1"></div>
        <div class="small">Time: <span id="timecode">00:00:00</span></div>
      </div>

      <div class="scrub">
        <input id="scrub" type="range" min="0" max="100" step="0.001" value="0" aria-label="Video scrubber"/>
        <div style="width:120px; text-align:right;" class="small">Frame: <span id="frameNum">0</span></div>
      </div>

      <div style="display:flex; gap:8px; margin-top:6px; align-items:center;">
        <button class="btn secondary" id="stepBackBtn" title="Step back one frame (Left Arrow)">◀ Frame</button>
        <button class="btn secondary" id="stepForwardBtn" title="Step forward one frame (Right Arrow)">Frame ▶</button>

        <button class="btn" id="screenshotBtn" title="Take full-frame screenshot (S)">Screenshot (S)</button>
        <button class="btn" id="cropBtn" title="Toggle crop tool (C)">Crop (C)</button>

        <label class="small" style="margin-left:8px">Screenshot mode</label>
        <select id="screenshotMode">
          <option value="full">Full-frame</option>
          <option value="crop">Crop (select on video)</option>
        </select>
      </div>
      <div class="small" style="margin-top:8px">Keyboard: Space=Play/Pause, ←/→ = frame step, S=Screenshot, C=Crop toggle, L=Log default count, B=Mark bite</div>
    </div>
  </section>

  <!-- RIGHT: side log panel -->
  <aside class="right" aria-labelledby="sideTitle">
    <h2 id="sideTitle" style="margin-top:0;font-size:16px">Logged species & quick actions</h2>

    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
      <label for="speciesSearch" class="small">Search / type species</label>
      <input id="speciesSearch" type="text" placeholder="Search species or type name" style="flex:1" />
      <button class="btn secondary" id="newSpeciesBtn">New</button>
    </div>

    <div style="display:flex; gap:6px; margin-bottom:8px;">
      <label for="speciesImages" class="small">Preload species images</label>
      <input id="speciesImages" type="file" accept="image/*" multiple />
    </div>

    <div class="side-panel" id="speciesList" role="list" aria-live="polite"></div>

    <hr />

    <div>
      <h3 style="margin:6px 0 4px 0">Quick log</h3>
      <div style="display:flex; gap:6px; align-items:center;">
        <select id="quickSpecies" style="flex:1">
          <option value="">-- select species --</option>
        </select>
        <button class="btn" id="quickLogBtn" title="Log an individual (default count=1, L)">Log (L)</button>
        <button class="btn secondary" id="quickBiteBtn" title="Mark bite (B)">Bite (B)</button>
      </div>
      <div class="small" style="margin-top:6px">Default add = 1 individual. For counts >1, type in the species card or use notes.</div>
    </div>
  </aside>

  <footer>
    <div class="small">Session: <span id="sessionInfo">Unsaved</span></div>
    <div class="small">Note: This is a client-side app — data is saved only on your machine unless you export it.</div>
  </footer>
</div>

<!-- JS dependencies: JSZip + FileSaver (CDN) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js" integrity="sha512-XkVQnW3m6e3E1rH5qOlVbq0U8Jm9i9qP/jtR5x/0t6VtQGJ8q/6b8j5nXQvNqQ4Gq1iYg1z9KZQK0Jq8z6V0g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js" integrity="sha512-5xkX0Y8YGr3oW6u0s1v1g9o3xI+qPUV1q4kqYfGQ+Pw9Vb8k3q6rqmTgO9Z0M6QeE6o1YFqF8M3Gz6Q0yFZ1Vw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
/*
Herbivory Tracking Tool - single-file app
- See header comments in HTML for high level features
- Well-commented for extension
*/

// --- Utility helpers -----------------------------------------------------
function fmtTimecode(seconds) {
  if (!isFinite(seconds)) return '00:00:00';
  const s = Math.floor(seconds);
  const hh = Math.floor(s/3600).toString().padStart(2,'0');
  const mm = Math.floor((s%3600)/60).toString().padStart(2,'0');
  const ss = Math.floor(s%60).toString().padStart(2,'0');
  return `${hh}:${mm}:${ss}`;
}

function safeText(s){ return (s||'').toString().replace(/"/g,'""'); }

// --- App state -----------------------------------------------------------
const state = {
  videoFile: null,
  videoURL: null,
  speciesGallery: [], // {name, file, url}
  speciesList: {}, // keyed by canonicalName -> {name, images, events:[], cumulative, maxN}
  events: [], // chronological events logged
  screenshots: [], // {id, dataUrl, filename, relatedEventId}
  autoAdvanceSeconds: 0,
  fps: 30
};

// --- DOM refs ------------------------------------------------------------
const videoEl = document.getElementById('video');
const videoFileIn = document.getElementById('videoFile');
const playPauseBtn = document.getElementById('playPauseBtn');
const speedSel = document.getElementById('speed');
const fpsInput = document.getElementById('fps');
const scrub = document.getElementById('scrub');
const timecodeSpan = document.getElementById('timecode');
const frameNumSpan = document.getElementById('frameNum');
const frameStepBackBtn = document.getElementById('stepBackBtn');
const frameStepForwardBtn = document.getElementById('stepForwardBtn');
const screenshotBtn = document.getElementById('screenshotBtn');
const cropBtn = document.getElementById('cropBtn');
const cropCanvas = document.getElementById('cropCanvas');
const screenshotMode = document.getElementById('screenshotMode');
const autoAdvanceSel = document.getElementById('autoAdvance');
const videoFilenameInput = document.getElementById('videoFilename');
const locInput = document.getElementById('loc');
const dateInput = document.getElementById('date');
const timeInput = document.getElementById('time');
const transectInput = document.getElementById('transect');
const reviewerInput = document.getElementById('reviewer');
const speciesImagesIn = document.getElementById('speciesImages');
const speciesSearch = document.getElementById('speciesSearch');
const newSpeciesBtn = document.getElementById('newSpeciesBtn');
const speciesListEl = document.getElementById('speciesList');
const quickSpeciesSel = document.getElementById('quickSpecies');
const quickLogBtn = document.getElementById('quickLogBtn');
const quickBiteBtn = document.getElementById('quickBiteBtn');
const exportZipBtn = document.getElementById('exportZipBtn');
const exportCsvBtn = document.getElementById('exportCsvBtn');
const sessionInfo = document.getElementById('sessionInfo');

// --- Video load and metadata --------------------------------------------
videoFileIn.addEventListener('change', async (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  if(state.videoURL) URL.revokeObjectURL(state.videoURL);
  state.videoFile = file;
  state.videoURL = URL.createObjectURL(file);
  videoEl.src = state.videoURL;
  videoFilenameInput.value = file.name;

  // try to set date/time from file's lastModified
  const d = new Date(file.lastModified);
  if (!dateInput.value) dateInput.value = d.toISOString().slice(0,10);
  if (!timeInput.value) timeInput.value = d.toTimeString().slice(0,5);

  sessionInfo.textContent = 'Loaded: ' + file.name;
});

// editable filename input stays in state when exporting
videoFilenameInput.addEventListener('input', ()=>{/* no-op, value read at export */});

// FPS input
fpsInput.addEventListener('change', ()=> {
  const v = Number(fpsInput.value);
  if (v>0) state.fps = v;
});

// Speed select
speedSel.addEventListener('change', ()=> {
  videoEl.playbackRate = Number(speedSel.value);
});

// Auto-advance
autoAdvanceSel.addEventListener('change', ()=> {
  const v = autoAdvanceSel.value;
  state.autoAdvanceSeconds = (v==='none') ? 0 : Number(v);
});

// --- Playback controls and scrubber -------------------------------------
playPauseBtn.addEventListener('click', togglePlay);
function togglePlay(){
  if(videoEl.paused) videoEl.play().catch(()=>{});
  else videoEl.pause();
}
videoEl.addEventListener('play', ()=> playPauseBtn.textContent='Pause (Space)');
videoEl.addEventListener('pause', ()=> playPauseBtn.textContent='Play (Space)');

// Update scrubber as video plays
videoEl.addEventListener('timeupdate', ()=>{
  const t = videoEl.currentTime;
  timecodeSpan.textContent = fmtTimecode(t);
  frameNumSpan.textContent = Math.round(t * state.fps);
  if(videoEl.duration){
    const v = (t / videoEl.duration) * 100;
    scrub.value = v;
  }
});

// When metadata loaded, set scrub max
videoEl.addEventListener('loadedmetadata', ()=>{
  scrub.value = 0;
});

// Scrub control user interaction
let isScrubbing = false;
scrub.addEventListener('input', (e)=>{
  isScrubbing = true;
  const val = Number(e.target.value);
  if(videoEl.duration){
    const t = (val / 100) * videoEl.duration;
    timecodeSpan.textContent = fmtTimecode(t);
    frameNumSpan.textContent = Math.round(t * state.fps);
  }
});
scrub.addEventListener('change', (e)=>{
  if(videoEl.duration){
    const t = (Number(e.target.value) / 100) * videoEl.duration;
    videoEl.currentTime = t;
  }
  isScrubbing = false;
});

// frame stepping (approximate using FPS value)
function stepFrame(deltaFrames){
  if(!videoEl.duration) return;
  const dt = deltaFrames / Math.max(1, state.fps);
  let newt = videoEl.currentTime + dt;
  newt = Math.max(0, Math.min(newt, videoEl.duration));
  videoEl.currentTime = newt;
}

// keyboard shortcuts
window.addEventListener('keydown', (ev)=>{
  if(ev.key === ' '){
    ev.preventDefault();
    togglePlay();
  } else if(ev.key === 'ArrowLeft'){
    ev.preventDefault();
    stepFrame(-1);
  } else if(ev.key === 'ArrowRight'){
    ev.preventDefault();
    stepFrame(1);
  } else if(ev.key.toLowerCase() === 's'){ // screenshot full-frame
    ev.preventDefault();
    takeScreenshot('full');
  } else if(ev.key.toLowerCase() === 'c'){ // toggle crop
    ev.preventDefault();
    toggleCropTool();
  } else if(ev.key.toLowerCase() === 'l'){ // quick log default
    ev.preventDefault();
    performQuickLog();
  } else if(ev.key.toLowerCase() === 'b'){ // quick bite
    ev.preventDefault();
    performQuickBite();
  }
});

// frame step buttons
frameStepBackBtn.addEventListener('click', ()=> stepFrame(-1));
frameStepForwardBtn.addEventListener('click', ()=> stepFrame(1));

// --- Cropping tool (simple click-drag on video to select bbox) -----------
let cropping = false;
let cropRect = null; // {x,y,w,h} in video pixel coords
const vContainer = videoEl;
cropBtn.addEventListener('click', toggleCropTool);
function toggleCropTool(){
  cropping = !cropping;
  cropCanvas.style.display = cropping ? 'block' : 'none';
  cropCanvas.width = videoEl.clientWidth;
  cropCanvas.height = videoEl.clientHeight;
  // position canvas to overlay video
  const rect = videoEl.getBoundingClientRect();
  cropCanvas.style.left = rect.left + 'px';
  cropCanvas.style.top = rect.top + 'px';
  cropCanvas.style.width = rect.width + 'px';
  cropCanvas.style.height = rect.height + 'px';
  cropCanvas.style.pointerEvents = 'auto';
  if(cropping) {
    cropCanvas.style.display = 'block';
    initCropCanvas();
  } else {
    cropCanvas.style.display = 'none';
    cropRect = null;
  }
}

// We'll implement cropping over the video element by capturing mouse on the cropCanvas
function initCropCanvas(){
  // draw overlay on the canvas positioned over video
  const box = videoEl.getBoundingClientRect();
  cropCanvas.style.position = 'absolute';
  cropCanvas.width = box.width;
  cropCanvas.height = box.height;
  cropCanvas.style.left = (videoEl.offsetLeft) + 'px';
  cropCanvas.style.top = (videoEl.offsetTop) + 'px';
  cropCanvas.style.display = 'block';
  const ctx = cropCanvas.getContext('2d');
  ctx.clearRect(0,0,cropCanvas.width,cropCanvas.height);

  // event handlers on cropCanvas (relative to its client area)
  let dragging = false;
  let start = null;
  function redraw(){
    ctx.clearRect(0,0,cropCanvas.width,cropCanvas.height);
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(0,0,cropCanvas.width,cropCanvas.height);
    if(start && dragging){
      const x = Math.min(start.x, current.x), y = Math.min(start.y, current.y);
      const w = Math.abs(current.x - start.x), h = Math.abs(current.y - start.y);
      ctx.clearRect(x,y,w,h);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(x+0.5,y+0.5,w,h);
    } else if(cropRect){
      ctx.clearRect(cropRect.x,cropRect.y,cropRect.w,cropRect.h);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(cropRect.x+0.5,cropRect.y+0.5,cropRect.w,cropRect.h);
    }
  }
  let current = {x:0,y:0};

  function toCanvasPos(e){
    const r = cropCanvas.getBoundingClientRect();
    return {x: Math.max(0, Math.min(r.width, e.clientX - r.left)), y: Math.max(0, Math.min(r.height, e.clientY - r.top))};
  }

  cropCanvas.onmousedown = (e)=>{
    dragging = true;
    start = toCanvasPos(e);
    current = {...start};
    redraw();
  };
  cropCanvas.onmousemove = (e)=>{
    if(dragging){
      current = toCanvasPos(e);
      redraw();
    }
  };
  cropCanvas.onmouseup = (e)=>{
    if(!dragging) return;
    dragging = false;
    const end = toCanvasPos(e);
    const x = Math.min(start.x, end.x), y = Math.min(start.y, end.y);
    const w = Math.abs(end.x - start.x), h = Math.abs(end.y - start.y);
    cropRect = {x,y,w,h};
    redraw();
  };
  // Clear crop on double click
  cropCanvas.ondblclick = ()=>{
    cropRect = null;
    redraw();
  };
  redraw();
}

// --- Screenshot capture --------------------------------------------------
function takeScreenshot(mode = null, relatedEventId = null){
  const m = mode || screenshotMode.value || 'full';
  if(!videoEl.videoWidth || !videoEl.videoHeight){
    alert('Video not ready for screenshot.');
    return;
  }

  // draw current video frame to canvas sized by actual video pixel dimensions
  const vidW = videoEl.videoWidth, vidH = videoEl.videoHeight;
  const canvas = document.createElement('canvas');
  canvas.width = vidW; canvas.height = vidH;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(videoEl, 0, 0, vidW, vidH);

  // if crop, map cropRect (which is in displayed pixel coords) to video pixel coords
  let finalCanvas = canvas;
  let filenameSuffix = '';
  if(m === 'crop' && cropRect){
    // cropCanvas's size corresponds to displayed video element size: map to video pixel dims
    const displayRect = videoEl.getBoundingClientRect();
    const scaleX = vidW / displayRect.width;
    const scaleY = vidH / displayRect.height;
    const sx = Math.round(cropRect.x * scaleX);
    const sy = Math.round(cropRect.y * scaleY);
    const sw = Math.round(cropRect.w * scaleX);
    const sh = Math.round(cropRect.h * scaleY);
    if(sw <= 0 || sh <=0) { alert('Crop too small'); return; }
    const c2 = document.createElement('canvas');
    c2.width = sw; c2.height = sh;
    c2.getContext('2d').drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);
    finalCanvas = c2;
    filenameSuffix = '_crop';
  }

  const dataUrl = finalCanvas.toDataURL('image/png');
  const id = 'ss_' + Date.now() + '_' + Math.floor(Math.random()*1000);
  const filename = (videoFilenameInput.value || 'video') + '_' + id + filenameSuffix + '.png';

  const screenshot = { id, dataUrl, filename, relatedEventId };
  state.screenshots.push(screenshot);
  sessionInfo.textContent = 'Screenshot captured: ' + filename;

  // show small visual feedback (brief highlight)
  // For MaxN flow, caller may use returned screenshot
  return screenshot;
}

// --- Species gallery preload & selection --------------------------------
speciesImagesIn.addEventListener('change', (e)=>{
  const files = Array.from(e.target.files || []);
  files.forEach(f=>{
    const url = URL.createObjectURL(f);
    const name = f.name.replace(/\.[^.]+$/,'').replace(/_/g,' ');
    state.speciesGallery.push({name, file:f, url});
  });
  rebuildSpeciesPicker();
});

// rebuild quickSpecies select and any selection UI
function rebuildSpeciesPicker(){
  // sort alphabetical
  const items = state.speciesGallery.slice().sort((a,b)=>a.name.localeCompare(b.name));
  quickSpeciesSel.innerHTML = '<option value="">-- select species --</option>';
  items.forEach((it,idx)=>{
    const opt = document.createElement('option');
    opt.value = it.name;
    opt.textContent = it.name;
    quickSpeciesSel.appendChild(opt);
  });

  // list species images in gallery for reference (we won't pre-create huge UI here)
}

// New species manual add
newSpeciesBtn.addEventListener('click', ()=>{
  const txt = speciesSearch.value.trim();
  const name = txt || prompt('Enter species/common name:');
  if(!name) return;
  addSpeciesIfMissing(name);
});

// Search filter (simple)
speciesSearch.addEventListener('input', (e)=>{
  const q = e.target.value.trim().toLowerCase();
  // filter species cards if gallery used - here we just set quickSpecies selection if exact matches
  if(q && state.speciesGallery.some(s=>s.name.toLowerCase().includes(q))){
    // no-op for now
  }
});

// --- Species card rendering & logging -----------------------------------
function addSpeciesIfMissing(name){
  const key = name.trim().toLowerCase();
  if(!key) return null;
  if(!state.speciesList[key]){
    state.speciesList[key] = {
      name: name.trim(),
      images: state.speciesGallery.filter(g => g.name.toLowerCase() === key).map(g=>g.url),
      events: [],
      cumulative: 0,
      maxN: 0
    };
    renderSpeciesCards();
    rebuildSpeciesPicker();
  }
  return state.speciesList[key];
}

function renderSpeciesCards(){
  // clear and repopulate
  speciesListEl.innerHTML = '';
  for(const key of Object.keys(state.speciesList)){
    const s = state.speciesList[key];
    const card = document.createElement('div');
    card.className = 'species-card';
    card.setAttribute('role','listitem');

    const info = document.createElement('div');
    info.className = 'species-info';

    const img = document.createElement('img');
    img.alt = s.name;
    img.src = (s.images && s.images[0]) ? s.images[0] : '';
    if(!img.src) img.style.background = '#ddd';
    info.appendChild(img);

    const textwrap = document.createElement('div');
    const nameEl = document.createElement('div');
    nameEl.className = 'species-name';
    nameEl.textContent = s.name;
    const stats = document.createElement('div');
    stats.className = 'small';
    stats.innerHTML = `Cumulative: <span id="cum_${key}">${s.cumulative}</span> &nbsp; MaxN: <strong id="maxn_${key}">${s.maxN}</strong>`;
    textwrap.appendChild(nameEl);
    textwrap.appendChild(stats);
    info.appendChild(textwrap);

    card.appendChild(info);

    // actions
    const actions = document.createElement('div');
    actions.className = 'log-actions';
    // quick add count button (default 1)
    const addBtn = document.createElement('button');
    addBtn.className = 'btn secondary';
    addBtn.textContent = '+1';
    addBtn.title = 'Add one individual (click to edit count)';
    addBtn.addEventListener('click', ()=>{
      const count = Number(prompt('Add how many individuals?','1')) || 1;
      logResighting(s.name, {type: 'resight', count});
    });

    const biteBtn = document.createElement('button');
    biteBtn.className = 'btn';
    biteBtn.textContent = 'Bite';
    biteBtn.title = 'Log bite';
    biteBtn.addEventListener('click', ()=>{
      const target = prompt('What did it bite? (free text)','turf algae');
      if(target===null) return;
      logResighting(s.name, {type: 'bite', biteTarget: target});
    });

    const newBtn = document.createElement('button');
    newBtn.className = 'btn';
    newBtn.textContent = 'New Sighting';
    newBtn.title = 'Log first sighting (takes screenshot optionally)';
    newBtn.addEventListener('click', ()=> {
      // when first spotted, allow selection from gallery or manual name; we already have s
      logFirstSighting(s.name);
    });

    actions.appendChild(addBtn);
    actions.appendChild(biteBtn);
    actions.appendChild(newBtn);
    card.appendChild(actions);

    speciesListEl.appendChild(card);
  }
}

// logging functions
function logFirstSighting(speciesName){
  addSpeciesIfMissing(speciesName);
  const t = videoEl.currentTime;
  const frame = Math.round(t * state.fps);
  const ev = {
    id: 'ev_' + Date.now() + '_' + Math.floor(Math.random()*1000),
    species: speciesName,
    eventType: 'first',
    timestamp: t,
    frame,
    countAdded: 1,
    cumulativeAfter: 0, // will fill below
    maxNAfter: 0,
    biteTarget: '',
    screenshotFilename: '',
    screenshotDataUrl: '',
    notes: ''
  };

  // optionally capture screenshot depending on screenshotMode
  const screenshotModeVal = screenshotMode.value;
  const ss = (screenshotModeVal==='full') ? takeScreenshot('full') : (screenshotModeVal==='crop' ? takeScreenshot('crop') : null);
  if(ss){
    ss.relatedEventId = ev.id;
    ev.screenshotFilename = ss.filename;
    ev.screenshotDataUrl = ss.dataUrl;
  }

  // update species cumulative & maxN (for first sighting, cumulative increments)
  const key = speciesName.trim().toLowerCase();
  const s = state.speciesList[key];
  s.cumulative = (s.cumulative || 0) + ev.countAdded;
  // MaxN logic: for first sighting, if countAdded > s.maxN then update; countAdded usually 1
  if(ev.countAdded > s.maxN){
    s.maxN = ev.countAdded;
  }
  ev.cumulativeAfter = s.cumulative;
  ev.maxNAfter = s.maxN;

  // push events list
  state.events.push(ev);
  s.events.push(ev);
  renderSpeciesCards();
  updateUIAfterEvent(s, ev);
  maybeAutoAdvance();
}

function logResighting(speciesName, opts={type:'resight', count:1, biteTarget:''}){
  addSpeciesIfMissing(speciesName);
  const t = videoEl.currentTime;
  const frame = Math.round(t * state.fps);
  const type = opts.type || 'resight';
  const countAdded = Number(opts.count) || 1;
  const biteTarget = opts.biteTarget || '';
  const key = speciesName.trim().toLowerCase();
  const s = state.speciesList[key];
  const prevCumulative = s.cumulative || 0;
  s.cumulative = prevCumulative + (type==='resight' ? countAdded : 0);
  // MaxN: we need to know instantaneous count in this frame (countAdded may represent how many seen simultaneously).
  // We'll assume user will enter total seen simultaneously as countAdded if that's the case.
  let newMax = s.maxN;
  if(type==='resight'){
    // if the current simultaneous number (countAdded) is greater than existing maxN, update and prompt screenshot
    // Note: This assumes countAdded refers to individuals seen simultaneously; for simple logging default is 1.
    if(countAdded > s.maxN){
      newMax = countAdded;
    }
  }
  s.maxN = newMax;

  const ev = {
    id: 'ev_' + Date.now() + '_' + Math.floor(Math.random()*1000),
    species: speciesName,
    eventType: type,
    timestamp: t,
    frame,
    countAdded,
    cumulativeAfter: s.cumulative,
    maxNAfter: s.maxN,
    biteTarget: biteTarget,
    screenshotFilename: '',
    screenshotDataUrl: '',
    notes: ''
  };

  // If this event increased maxN, show prompt and offer immediate screenshot
  if(type==='resight' && countAdded > ev.maxNAfter - 0){ /* nothing */ }
  // Actually check increased:
  if(type==='resight' && countAdded > (s.maxN - (countAdded>0 ? 0 : 0)) && countAdded === s.maxN){
    // It is new MaxN
    // Tell the user and offer button to capture screenshot of that frame
    if(confirm(`New MaxN for ${speciesName} = ${s.maxN}. Capture screenshot now?`)){
      const ss = takeScreenshot('full', ev.id);
      if(ss){
        ss.relatedEventId = ev.id;
        ev.screenshotFilename = ss.filename;
        ev.screenshotDataUrl = ss.dataUrl;
      }
    }
    // visual highlight is done in render
  }

  // attach screenshot if screenshotMode is full and user wants automatic
  if(screenshotMode.value === 'full' && type==='resight'){
    // auto capture screenshot associated with the event
    const ss2 = takeScreenshot('full', ev.id);
    if(ss2){
      ss2.relatedEventId = ev.id;
      ev.screenshotFilename = ss2.filename;
      ev.screenshotDataUrl = ss2.dataUrl;
    }
  }

  // push
  state.events.push(ev);
  s.events.push(ev);
  renderSpeciesCards();
  updateUIAfterEvent(s, ev);
  maybeAutoAdvance();
}

function updateUIAfterEvent(speciesObj, ev){
  // highlight updated species card
  // find element with matching species name
  const nodes = Array.from(speciesListEl.querySelectorAll('.species-card'));
  for(const n of nodes){
    if(n.innerText.includes(speciesObj.name)){
      n.classList.add('highlight');
      setTimeout(()=> n.classList.remove('highlight'), 900);
      break;
    }
  }
  // update session info
  sessionInfo.textContent = `Last: ${ev.eventType} ${ev.species} @ ${fmtTimecode(ev.timestamp)}`;
}

// Quick log UI actions
quickLogBtn.addEventListener('click', performQuickLog);
function performQuickLog(){
  const sp = quickSpeciesSel.value || speciesSearch.value.trim();
  if(!sp){ alert('Choose/enter species'); return; }
  addSpeciesIfMissing(sp);
  logResighting(sp, {type: 'resight', count: 1});
}
quickBiteBtn.addEventListener('click', performQuickBite);
function performQuickBite(){
  const sp = quickSpeciesSel.value || speciesSearch.value.trim();
  if(!sp){ alert('Choose/enter species'); return; }
  addSpeciesIfMissing(sp);
  const t = prompt('What did it bite?');
  if(t===null) return;
  logResighting(sp, {type: 'bite', biteTarget: t});
}

// maybe auto advance video a bit after logging
function maybeAutoAdvance(){
  if(state.autoAdvanceSeconds && !isNaN(state.autoAdvanceSeconds) && state.autoAdvanceSeconds>0){
    videoEl.currentTime = Math.min(videoEl.duration || Infinity, videoEl.currentTime + state.autoAdvanceSeconds);
  }
}

// --- Export: CSV & ZIP --------------------------------------------------
function buildCSVRows(){
  const headerMeta = ['Field','Value'];
  const meta = [
    ['Location', locInput.value||''],
    ['Date', dateInput.value||''],
    ['Time', timeInput.value||''],
    ['Transect', transectInput.value||''],
    ['Reviewer', reviewerInput.value||''],
    ['Video filename', videoFilenameInput.value || (state.videoFile ? state.videoFile.name : '')]
  ];

  // per-event rows header
  const fields = ['event_id','timestamp_s','timecode','frame','species','event_type','count_added','cumulative_after','maxN_after','bite_target','screenshot_filename','screenshot_dataurl','notes'];

  // build rows
  const rows = state.events.map(ev=>{
    return [
      safeText(ev.id),
      ev.timestamp.toFixed(3),
      fmtTimecode(ev.timestamp),
      ev.frame,
      safeText(ev.species),
      safeText(ev.eventType),
      ev.countAdded,
      ev.cumulativeAfter,
      ev.maxNAfter,
      safeText(ev.biteTarget || ''),
      safeText(ev.screenshotFilename || ''),
      // embed data URLs optionally - may be large. We'll include data URLs in CSV too (user requested)
      ev.screenshotDataUrl ? '"' + safeText(ev.screenshotDataUrl) + '"' : '',
      safeText(ev.notes || '')
    ].join(',');
  });

  // assemble CSV text
  let csv = '';
  csv += headerMeta.join(',') + '\n';
  meta.forEach(m => { csv += `"${safeText(m[0])}","${safeText(m[1])}"\n`; });
  csv += '\n';
  csv += fields.join(',') + '\n';
  csv += rows.join('\n');
  return csv;
}

async function exportZip(){
  // validate metadata
  if(!videoFilenameInput.value.trim() || !locInput.value.trim()){
    if(!confirm('Some metadata (Location or filename) is empty. Continue export?')) return;
  }
  const zip = new JSZip();
  // csv
  const csvText = buildCSVRows();
  zip.file('annotations.csv', csvText);

  // include screenshots as files
  const imgFolder = zip.folder('screenshots');
  for(const ss of state.screenshots){
    // dataUrl -> binary
    const b64 = ss.dataUrl.split(',')[1];
    imgFolder.file(ss.filename, b64, {base64: true});
  }

  // optionally include a small manifest JSON
  const manifest = {
    exportedAt: (new Date()).toISOString(),
    videoFilename: videoFilenameInput.value || (state.videoFile ? state.videoFile.name : '')
  };
  zip.file('manifest.json', JSON.stringify(manifest, null, 2));

  const content = await zip.generateAsync({type:'blob'});
  saveAs(content, (videoFilenameInput.value || 'annotations') + '_export.zip');
}

exportZipBtn.addEventListener('click', exportZip);

exportCsvBtn.addEventListener('click', ()=>{
  const csv = buildCSVRows();
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  saveAs(blob, (videoFilenameInput.value || 'annotations') + '.csv');
});

// --- On load: initialize default UI -------------------------------------
(function init(){
  // set default speed to 2x (or 3x) - but user requested only options 1.5..5; UI default left at 1.5x
  speedSel.value = '2';
  videoEl.playbackRate = Number(speedSel.value);
  renderSpeciesCards();
})();

</script>
</body>
</html>
